<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BibTeX to HTML App</title>
    
    <link rel="stylesheet" href="https://pyscript.net/releases/2023.05.1/pyscript.css" />
    <script defer src="https://pyscript.net/releases/2023.05.1/pyscript.js"></script>
    <style> html { all: unset; } </style>
    <link rel="stylesheet" href="/style/style.css">

    <style>
        html {
            all: unset;
        }
        iframe {
            width: 100%; height: 400px; border: 1px solid #ccc;
            background: #fff; box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
    </style>
</head>
<body>
    <h2>BibTeX to HTML Converter</h2>
    Here is a Python script that does the same job: <a href="/cs/bibtex_to_html/bib_to_html.py">bib_to_html.py</a>
    <p>
    </p>
    
    <div id="status">Initializing Python...</div>

    <div class="container">
        <div class="box">
            <h3>1. Paste BibTeX Here</h3>
            <textarea id="bib-input" placeholder="@article{...}"></textarea>
            <button id="btn-convert">Generate HTML</button>
        </div>

        <div class="box">
            <h3>2. Raw HTML Code</h3>
            <textarea id="html-output" placeholder="The generated code will appear here..."></textarea>
        </div>
    </div>

    <h3>3. Live Preview</h3>
    <iframe id="preview-frame"></iframe>

    <py-config>
        packages = ["bibtexparser"]
    </py-config>

    <py-script>
import bibtexparser
from bibtexparser.customization import convert_to_unicode
from bibtexparser.bparser import BibTexParser
from js import document
from pyodide.ffi import create_proxy

# --- 1. LOGIC ---

def get_author_string(entry):
    if 'author' in entry:
        authors = entry['author'].split(' and ')
        formatted_authors = []
        for author in authors:
            author = author.strip()
            if "," in author:
                parts = [p.strip() for p in author.split(",")]
                last = parts[0]
            else:
                parts = author.split()
                last = parts[-1]
            formatted_authors.append(f"{last}")

        if len(formatted_authors) > 1:
            return ", ".join(formatted_authors[:-1]) + f" & {formatted_authors[-1]}"
        elif formatted_authors:
            return formatted_authors[0]
    return ""

def format_bibtex_entry(entry):
    title = entry.get('title', 'Unknown title')
    author_str = get_author_string(entry)
    year = entry.get('year', 'n.d.')
    
    link = entry.get('url', entry.get('doi', '#'))
    if link != '#' and not (link.startswith('http') or link.startswith('ftp')):
            if 'doi' in entry:
                link = f"https://doi.org/{entry['doi']}"
            else:
                link = '#'

    custom_note = ""
    if entry.get('note', '').startswith('(') and entry.get('note', '').endswith(')'):
        custom_note = entry['note'].strip()
    
    container = ""
    volume = ""
    pages = ""
    
    if 'journal' in entry:
        container = f"<em>{entry['journal']}</em>"
    elif 'booktitle' in entry:
        container = f"<em>In {entry['booktitle']}</em>"
    elif 'publisher' in entry:
        container = f"<em>{entry['publisher']}</em>"
        
    if 'volume' in entry:
        volume = f", Vol. {entry['volume']}"
    if 'pages' in entry:
        pages_val = entry['pages'].replace('--', 'â€“')
        pages = f", pp. {pages_val}"
    
    # Using triple quotes for the block, but f-strings inside use single quotes for attributes if needed
    html = f"""
<li>
<p>{author_str} ({year}).
<br>
<a href="{link}" class="external">{title}</a>"""
    
    for a in range(2,31):
        key = 'url_'+str(a)
        if key not in entry:
            break
        note_key = 'url_note_'+str(a)
        if note_key not in entry:
            url_note = 'link '+str(a)
        else:
            url_note = entry[note_key]
        
        # CORRECT QUOTING: Outer single ', Inner double "
        html += f' <a href="{entry[key]}" class="external">[{url_note}]</a>'

    if custom_note:
        html += f" <strong>{custom_note}</strong>."
    else:
        html += "."
    
    if container or volume or pages:
        html += f" {container}{volume}{pages}."
    
    html += "</p>\n</li>"
    return html

# --- 2. HANDLER ---

def convert_bibtex(event):
    input_el = document.getElementById("bib-input")
    output_el = document.getElementById("html-output")
    status_el = document.getElementById("status")
    preview_frame = document.getElementById("preview-frame")

    content = input_el.value
    if not content:
        status_el.innerHTML = '<span style="color:red">Error: Please paste BibTeX content first.</span>'
        return

    status_el.innerHTML = "Processing..."

    try:
        parser = BibTexParser()
        parser.customization = convert_to_unicode
        bib_database = bibtexparser.loads(content, parser=parser)

        if not bib_database.entries:
            status_el.innerHTML = "No entries found."
            return

        sorted_entries_1 = sorted(
            bib_database.entries, 
            key=lambda entry: entry.get('author', '').split(' and ')[0].split(',')[0].split()[-1].lower()
        )
        sorted_entries = sorted(
            sorted_entries_1, 
            key=lambda entry: entry.get('year', '')
        )

        list_content = ""
        for entry in sorted_entries:
            list_content += format_bibtex_entry(entry)

        # Full HTML Template
        full_html = f"""<!DOCTYPE html>
<html lang="it">
<head>
<meta charset="UTF-8">
<title>Converted bibliography</title>
<style>
    body {{ font-family: sans-serif; padding: 20px; }}
    li {{ margin-bottom: 1em; }}
    .external {{ text-decoration: none; color: #0066cc; }}
    .external:hover {{ text-decoration: underline; }}
</style>
</head>
<body>
<h1>References</h1>
<ul>
{list_content}
</ul>
</body>
</html>"""

        # 1. Show Code
        output_el.value = full_html
        
        # 2. Show Preview (Render the HTML in the iframe)
        preview_frame.srcdoc = full_html
        
        status_el.innerHTML = '<span style="color:green">Done! Check the Code and Preview below.</span>'

    except Exception as e:
        # CORRECT QUOTING: Outer single ', Inner double "
        status_el.innerHTML = f'<span style="color:red">Python Error: {str(e)}</span>'

# --- 3. BIND ---
proxy = create_proxy(convert_bibtex)
document.getElementById("btn-convert").addEventListener("click", proxy)

document.getElementById("status").innerHTML = "Ready."
    </py-script>

</body>
</html>